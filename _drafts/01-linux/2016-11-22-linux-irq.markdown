---
layout: post
title: Linux - 中断处理（读书笔记）
---

## 1. 中断
中断请求（IRQ），中断处理程序/中断服务例程（Interrupt service routine，ISR）。

中断处理可以分为上半部分（top half）和下半部分（bottom half，BH）。我们希望中断程序处理的工作越少越好，中断程序能够尽快返回。下半部分执行与中断处理密切相关，但是中断程序不执行的工作。

linux提供一个一些下半部分的机制：下半部分BH（注意这只是早期实现的机制叫法）、任务队列、软中断和tasklet、工作队列。


## 2. 软中断
软中断是在编译期间静态分配的，它不像tasklet那样能被动态地注册或注销。最多只有32个软中断。
一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是中断处理程序。

一个注册的软中断必须在被标记后才会执行。这被称作触发软中断。中断程序会在返回前标记软中断，于是改软中断在合适的时机被执行。do_softirq()循环遍历处理软中断。

软中断保留给系统中对时间要求严格以及最重要的下半部使用。目前只有网络和SCSI直接使用软中断，另外内核定时器和tasklet都是建立在软中断上面的。

如果同一个软中断中断在执行中的时候再次被触发，另外一个处理器可以运行相同程序，这意味着数据共享。需要加锁保护。


## 3. tasklet
tasklet是利用软中断实现的一种下半部机制。它的接口简单，锁保护要求也低。
tasklet本质上也是软中断，不过不支持多处理器运行统一程序的多个实例。

通常你应该使用tasklet。

通过检查TASKLET_STATE_RUN来判断tasklet是否在其他处理器上运行。如果他在运行，则现在不执行。即同意时间内只能执行一个tasklet。如果当前这个tasklet没有执行，则将其状态设置为TASKLET_STATE_RUN，这样别的处理器就不会执行它了。

tasklet通过重复运用HI_SOFTIRQ和TASKLET_SOFTIRQ这两个软中断实现。

tasklet靠软中断实现，所以tasklet不能睡眠，这意味着不能再tasklet中使用信号量或者其他什么阻塞式的函数。

一个tasklet总在调度它的处理器上执行，这是希望能够更好地利用处理器中的告诉缓存。

### 3.1 ksoftirqd
每个处理器都有一组辅助处理软中断（和tasklet）的内核线程，ksoftirqd/n（n对应处理器编号）。当内核出现大量软中断请求，内核会唤醒一组内核线程来处理这些负载。这些线程在最低的优先级上运行（nice值为19）。

设计目的：保证在大量软中断时，用户程序不会得不到处理器时间而处于饥饿状态，也能保证过量的软中断最终能够得到处理。

## 4. 工作队列
工作队列（work queue）是另外一种将工作推后执行的形式。
工作队列把工作推后，交给一个内核线程去执行，这个下半部分总是会在 `进程上下文` 中执行！因此，工作队列允许重新调度甚至睡眠，所以在需要获得信号量、执行阻塞式I/O操作时，他都会非常有用。

如果推后执行的任务需要睡眠，那么就选择工作队列，如果不需要，那么选择软中断或tasklet。

工作队列子系统是一个用于创建内核线程的接口，通过它创建的线程负责执行内核其他部分分排到队列里的任务。这些线程叫做工作者线程（worker thread）。工作队列子系统提供了一个缺省的工作者线程处理这些工作。缺省的工作者线程叫做events/n（n是处理器编号）。

工作以链表方式组织，当有工作加入，工作者线程被唤醒，执行死循环读取所有工作，直至读取完。

工作队列的使用
 `DECLARE_WORK(name, void (*func)(void*), void* data);` 会创建一个名为name，处理函数为func，参数为data的work_struct结构体。
也可以在运行时通过指针创建一个工作： `INIT_WORK(struct work_struct* work, void(*func)(void*), void* data);`。

工作队列处理函数： `void work_handler(void* data);`
运行过程中不能范文用户空间！！！

对工作进行调度： `schedule_work(&work); or schedule_delay_work(&work, delay);`

刷新制定队列工作， `void flush_scheduled_work(void);` 该函数会一直等待，直到队列中所有对象都被执行以后才返回。

如果缺省的队列不能满足要求，可以创建新的工作队列。
