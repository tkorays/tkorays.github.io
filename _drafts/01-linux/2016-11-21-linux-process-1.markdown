---
layout: post
title: Linux - 进程调度（读书笔记）
---
本文是《Linux内核设计与实现》的读书笔记，摘记自己觉得需要关注的内容。

## 1. 多任务
多任务系统中，任务可以分为：
* 非抢占式多任务（cooperative multitasking）
* 抢占式多任务（preemptive multitasking）
linux提供了抢占式多任务模式。非抢占式的操作系统需要每个进程自动挂起自己的操作，称为让步（yielding）。

## 2. 策略
进程可以被分为I/O消耗型和处理器消耗型。

调度程序总是选择时间片未用尽且优先级最高的程序运行，相同优先级程序按轮转方式调度。因此，用户可以通过设置进程优先级来影响系统的调度。

Linux采用两种优先级范围：

1） Nice值，范围从-20至19，默认为0.数值越小，优先级越高，数值越大，优先级也越低，但是低优先级进程可以活的更多的处理器时间。（ps -el，N1列）

2） 实时优先级，范围从0到99，可以配置。数值越大，进程优先级越高。任何实时进程的优先级高于普通进程。（ps -eo state,uid,pid,ppid,rtprio,time,comm，RTPRIO，如果为-表示不是实时进程）

`时间片` 表示进程在被抢占前所能持续运行的时间。时间片太长会导致单一进程占用CPU无法并发，太短导致进程切换频繁浪费太多CPU时间。I/O消耗型不需要太长时间片，而处理器消耗型则希望越长越好。

linux中的CFS调度器并没有直接分配时间片给进程，而是将处理器的使用比划分给进程。

## 3. Linux调度算法
uninx进程调度基于进程优先级和时间片。unix里面的时间片采用绝对时间不合理：1）低优先级差值明显（相对的），高优先级差别可忽略；2）时间必须为节拍的整数。

CFS公平调度，我们期望每个进程都能获得1/n的处理器时间。
CFS允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。

CFS引入了每个进程获得时间片的底线，这个底线称为最小粒度。默认为1ms。

CFS称为公平调度器是因为它确保给每个进程公平的处理器使用比。CFS不是完美的公平，而是近乎完美。

## 4. Linux调度实现

### 4.1 时间记账
给每个进程记录运行时间。

### 4.2 进程选择
CFS调度算法的核心是选择最小的vruntime任务。
CFS采用红黑树来组织可运行进程队列，并迅速找到最小的vruntime值的进程。

### 4.3 调度器入口
调度器的主入口函数是schedule。

### 4.4 睡眠和唤醒
休眠：进程把自己标记为休眠状态，并从可执行红黑树中移除，放入等待队列。唤醒：进程被置为可执行状态，从等待队列移到可执行红黑树中。

## 5. 抢占和上下文切换
用户抢占：从系统调用返回用户空间；从中断处理程序返回用户空间。
内核抢占：中断处理程序正在执行，且返回内核空间之前；内核代码再一次具有可抢占性的时候；内核中显式调用shcedule；内核中任务阻塞。
只要没有锁就可以抢占。


## 6. 实时调度策略
SCHED_FIFO，
SHCED_RR，带有时间片的FIFO，实时轮流调度算法。
非实时：SCHED_NORMAL

