---
layout: post
title: TFRC:TCP-Friendly Rate Control
---

TFRC，即TCP-Friendly rate control，是一个为单播流设计的拥塞控制机制，使用了和TCP类似的吞吐量方程，在网络中可以和TCP很好地竞争。主要应用场景是应用层需要有平滑的吞吐量，固定报文大小，发生拥塞时，发送码率是秒级地变化。

TFRC是一个基于接收端的机制，也就是说拥塞的计算是在接收端，而不是发送端。基于接收端的机制更适用于广播场景，因为将计算放在接收端，可以将计算分布到分担到各个接收端而不是一个发送端。

【注】TFRC-PS和TFRC不同，报文大小不必相同，可以通过调整报文大小，保持拥有固定发送码率。

## 1. 原理
TFRC的拥塞控制，基于丢包事件和环路时延建立吞吐量方程，根据这个方程得到发送码率。TCP的吞吐量方程粗略地将发送码率看成是丢包率、环路时延、包大小的方程，因此为了很好地和TCP竞争，TFRC也使用了TCP的吞吐量方程。TFRC里面定义的丢包事件是指，一个以及多个丢包或者是窗口内的被标记的包，这里的mark包用来明确地表明有拥塞Explicit Congestion Notification。

工作机制：

* 接收端测量丢包事件频率（loss event rate），并将这些信息反馈给发送端
* 发送端根据反馈信息计算环路时延RTT
* 丢包事件率和环路时延RTT被输入到TFRC的吞度量方程中，给出一个可接收的传输速率估计
* 发送端调整自己的传输速率以匹配上计算的速率

## 2. TCP吞吐量方程
TFRC使用了和TCP类似的方程，输入为loss event rate和RTT，但是需要注意的是TCP的吞吐量方程考虑到了TCP的重传超时行为，这导致TCP有很高的丢包率。当前TFRC使用的吞吐量方程是Reno TCP的简化版本，作者认为的理想型的是使用SACK TCP模型。

方程如下：

$$
X = s / (R*\sqrt{2*b*p/3} + (t\_RTO * (3*\sqrt{3*b*p/8} * p * (1+32*p^2))))
$$