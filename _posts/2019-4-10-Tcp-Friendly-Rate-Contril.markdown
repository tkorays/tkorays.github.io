---
layout: post
title: TFRC:TCP-Friendly Rate Control
---

TFRC，即TCP-Friendly rate control，是一个为单播流设计的拥塞控制机制，使用了和TCP类似的吞吐量方程，目的是为了在网络中可以和TCP公平地竞争。主要应用场景是应用层需要有平滑的吞吐量，固定报文大小，发生拥塞时，发送码率是秒级地变化。

TFRC是一个基于接收端的机制，也就是说拥塞的计算是在接收端，而不是发送端。基于接收端的机制更适用于广播场景，因为将计算放在接收端，可以将计算分布到分担到各个接收端而不是一个发送端。

【注】TFRC-PS和TFRC不同，报文大小不必相同，可以通过调整报文大小，保持拥有固定发送码率。

## 1. 原理
TFRC的拥塞控制，基于丢包事件和环路时延建立吞吐量方程，根据这个方程得到发送码率。TCP的吞吐量方程粗略地将发送码率看成是丢包率、环路时延、包大小的方程，因此为了很好地和TCP竞争，TFRC也使用了TCP的吞吐量方程。TFRC里面定义的丢包事件是指，一个以及多个丢包或者是窗口内的被标记的包，这里的mark包用来明确地表明有拥塞Explicit Congestion Notification。

工作机制：

* 接收端测量丢包事件率（loss event rate），并将这些信息反馈给发送端
* 发送端根据反馈信息计算环路时延RTT
* 丢包事件率和环路时延RTT被输入到TFRC的吞度量方程中，给出一个可接收的传输速率估计
* 发送端根据计算的速率调整自己的传输速率

## 2. TCP吞吐量方程
TFRC使用了和TCP类似的方程，输入为丢包事件率和RTT，但是需要注意的是TCP的吞吐量方程考虑到了TCP的重传超时行为，这导致TCP有很高的丢包率。当前TFRC使用的吞吐量方程是Reno TCP的简化版本，作者认为的理想型的是使用SACK TCP模型。

方程如下：

$$
X = s / (R*\sqrt{2*b*p/3} + (t\_RTO * (3*\sqrt{3*b*p/8} * p * (1+32*p^2))))
$$

* X表示每秒传输字节数
* s表示每个包字节数
* R表示环路时延，单位秒
* p表示丢包事件率，范围0~1.0
* t_RTO表示TCP重传超时时间，单位秒
* b表示每个TCP ACK包里面确认了多少个

在TFRC里面把t_RTO简化成t_RTO = 4*R。现在很多TCP延迟确认，即一个包确认多个接收，而很多TCP实现中一个ACK只确认一个接收，因此这里b取1。


## 3. 数据包
发送端的包需要包含以下内容：

* 序号，每次自增1，序号字段需要足够大，避免序号翻转，导致一段时间内两个包有相同序号。
* 时间戳，表明该包的发送时间。接收端根据时间戳统计丢包事件，也可以将其发送会发送端用于计算环路时延RTT。
* 发送端估计的环路时延，发送到接收端，用于统计丢包事件。

接收端发送反馈报文：

* 上次收到包的时间。用于发送端估计环路时延RTT。
* 上次收包到本次发送反馈报文，之间的时间间隔。
* 从上次发送反馈报文开始统计，接收端的接收码率。
* 接收端估计的丢包事件率。

## 4. 数据发送端协议
数据发送端按照接收端端反馈的码率来发包，如果发送端在两个RTT时间内都没有收到任何反馈包，那么发送端会将其发送码率减半。这由无反馈定时器实现。

### 4.1 统计包大小
这个协议里，假定包大小以来于数据，虽然有变化，而不受码率控制，也就是可以统计出平均包大小。

---

_如果您觉得文章对您有用能够解决您的问题，欢迎您通过扫码进行打赏支持，谢谢！_

<img src="/public/post/img/alipay.jpg" style="width: 200px;margin:auto auto;"/>

