---
layout: post
title: Linux - 内核同步方法（读书笔记）
---

## 1. 原子操作
原子操作就是不能被分割的指令。linux提供了两组原子操作的接口：

* 一组针对整数（atomic_t，asm/atomic.h，编译器不会针对该类型优化）进行操作，atomic_inc，atomic_dec等等，64位上有atomic64_t。
* 一组针对单独的位进行操作，asm/bitops.h。

## 2. 自旋锁
 自旋锁最多只能被一个线程持有，如果一个线程试图获得一个已经被持有的自旋锁，那么该线程就会一直进行忙循环-》旋转-》等待锁重新可用。自旋比较浪费时间！！！所以自旋锁不应该被长时间持有。

自旋锁的实现和体系结构密切相关。linux/spinloc.h。

```
DEFINE_SPINLICK(mr_lock);
spin_lock(&mr_lock);
/* Critical Section */
spin_unlock(&mr_lock);
```

Linux内核中的自旋锁不可递归！小心自死锁！

自旋锁可以用在中断处理程序中（信号量不可以，他会导致睡眠， 这是 `血的教训！` ，前几天就遇到一个网络协议栈中信号量导致内核调度问题 ）。中断程序中在获取锁之前先要禁止当前处理器上的中断spin_lock_irqsave、spin_unlock_irqstore。

创建一个自旋锁：spin_lock_init。

spin_lock_bh用于获取制定锁，同时它会禁止所有下半部的执行，spin_unlock_bh相反。

## 3. 读写锁
读写自旋锁，一个或多个读任何可以并发地持有读者锁；相反，用于写的锁最多只能被一个写任务持有，而且此时不能有并发的读操作。有时把读写锁叫做共享/排斥锁、并发/排斥锁。因为这种锁以共享（对读者而言）和排斥（对写者而言）的形式获得使用。

```
DEFINE_RWLOCK(mr_rwlock);

read_lock(&mr_rwlock);
/* read only */
read_unlock(&mr_rwlock);

write_lock(&mr_lock);
/* read & write */
write_unlock(&mr_rwlock);
````


* 写锁不会自旋，它会等待自己释放，造成死锁。
* 大量的读者会使写者处于饥饿状态
* 如果加锁时间不长而且代码不会睡眠（中断），使用自旋锁是最佳的选择

## 4. 信号量
内核中唯一允许睡眠的锁是信号量！！！

Linux中信号量是一种 `睡眠锁` ，如果一个任务试图获得一个不可用（已经被占用）的信号量时，信号量将会将其推进一个等待队列，然后让其睡眠。当持有的信号量可用后，处于等待队列中的那个任务被唤醒，并获得信号量。

信号量优于自旋锁的地方在于睡眠可以提高cpu利用率。

* 争用信号量的进程在等待锁定 过程中可以睡眠，所以信号量适用于锁被长期持有的情况。
* 短期持有不适合使用信号量，因为睡眠唤醒、维护等待队列开销比较大，比锁占用的时间可能都要长。
* 只能在进程上下文中才能获取信号量，在中断上下文中是不能进行调度的！！
* 占用信号量的同事不能占用自旋锁，因为等待信号量时可能睡眠，而在持有自旋锁是不允许睡眠。

计数信号量和二进制信号量（互斥信号量），内核中基本上用到的都是互斥信号量（计数等于1的信号量）。

P、V，或者down、up。asm/semaphore.h。

## 5. 读写信号量
linux/rwsem.h，和读写自旋锁类似。

不同的是多了一种特有的操作：downgrade_write，可以动态地将写锁转换为读锁。

## 6. 互斥体
互斥体是指任何可以睡眠的强制互斥锁。他是一个简化版的信号量。但是有很多约束：

* mutex上锁者必须负责给给解锁，不能再一个上下文中锁定，在另一个上下文中解锁。因此不适合复杂的同步场景。
* 递归地上锁和解锁是不允许的，你不能递归地持有同一个锁，也不能去解锁一个已经被解开的锁。
* 在持有一个mutex时，进程不能退出。
* mutex不能再中断或下半部中使用，及时mutex_trylock也不行。
* mutex只能通过官方api初始化，不饿能够通过拷贝、手动或重复初始化。


## 7. 完成变量（completion variable）
一个任务需要发出信号通知另一个任务发生了某个特定事件。linux/completion.h。

## 8. 大内核锁 BKL
全局自旋锁。略。

## 9. 顺序锁
seq锁。用于读写共享数据。引入一个序列计数器，当有疑义的数据被写入时，会得到一个锁，并且序列值会增加。在读取数据之前和之后，序列号都被读取。如果读取的序号相同，说明在读操作过程中没有被写操作打断过。此外，如果读取的是偶数，表明写操作没有发生（锁初始值为0，写操作会使值变成计数，释放的时候变成偶数）

## 10. 内核抢占
Linux内核是抢占性的，自旋锁可以作为内核非抢占区域标记。如果一个自旋锁被持有，则内核不能进行抢占。