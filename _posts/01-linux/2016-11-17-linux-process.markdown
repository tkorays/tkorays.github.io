---
layout: post
title: Linux - 进程管理（读书笔记）
---
本文是《Linux内核设计与实现》的读书笔记，摘记自己觉得需要关注的内容。

## 1. 进程与线程
线程就是处于执行器的程序，它不仅仅局限于一段可执行的代码，还包含其他资源。

线程，是进程活动中的对象，每一个线程拥有单独的程序计数器、线程栈和一组进程寄存器。内核调度的对象是线程而不是进程。

Linux并不严格区分进程和线程，线程只不过是一种特殊的进程罢了。

现代操作系统中，进程提供两种虚拟机制：`虚拟处理器`和`虚拟内存`。线程间可以共享虚拟内存，但是各自仍拥有自己的虚拟处理器。

## 2. 进程描述符
内核把进程的列表存放在叫做`任务队列`的双向循环链表中。链表中的每一项为一个进程描述符(task_struct，linux/sched.h)，包含一个具体进程的所有信息。

task_struct在32位机器上面，大约有1.7KB。

linux通过slab分配器分配task_struct结构，这样可以达到对象复用和缓存着色的目的（预先分配、重复使用）。

内核通过一个唯一的进程标识值PID（pid_t，int类型，linux/threads.h）来标识每个进程。PID的默认最大值为32768，可以通过修改／proc/sys/kernel/pid_max来提高上限。

进程的五种状态：
* TASK_RUNNING（运行）
* TASK_INTERRUPTIBLE（可中断），进程正在睡眠，等待被唤醒
* TASK_UNINTERRUPTIBLE (不可中断)
* __TASK_TRACED，被其他进程跟踪的进程
* __TASK_STOPPED（停止），进程停止执行。通常这种状态发生在接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU等信号。另外，在调试期间接收到任何信号，都会使进程进入这种状态。

设置进程状态：set_task_state(task, state)、set_current_state(state)（linux/sched.h）。

所有的进程都属于PID为1度init进程后代。系统的每一个进程都必有一个父进程，进程的关系存放在进程描述符中。

## 3. 进程创建
和其他操作系统不同，linux创建一个线程分为两个步骤，fork和exec。fork通过拷贝当前进程创建一个子进程，子进程与父进程的PID和PPID不同。exec负责读取可执行文件，并载入地址空间开始运行。

传统的fork直接把所有系统资源复制给新创建的进程。linux的fork使用写时拷贝（copy-on-write）页实现。如果新进程直存在读取而没有写入，则没有必要拷贝数据。fork的最大开销就是复制父进程页表以及给子进程创建进程描述符。

linux使用clone()系统调用实现fork()。
vfork()不拷贝父进程页表，其他功能与fork()相同。这意味着子进程不能向地址空间写入。

## 4. 进程结束
wait这一族函数都是通过唯一的一个系统调用wait4来实现的，它的标准动作使刮挂起它的进程，直到其中一个子进程推出。

如果一个父进程在子进程之前退出，会产生孤儿进程。一般父进程在退出前在do_exit()中调用exit_notify()，调用forget_original_parent()、find_new_parent()来执行寻父过程，如果不行就让init做它的父进程。