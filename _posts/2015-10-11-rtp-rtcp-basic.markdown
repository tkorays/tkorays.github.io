---
layout: post
title: RTP & RTCP 基础
date: 2015-10-11 10:12:04
description: RTP（Real-time Transport Protocol）和RTCP(Real-time Transport Control Protocol)是在RFC3550中定义的一对网络传输协议协议，两者相互配合完成数据传输。
categories:
- blog
---

RTP，Real-time Transport Protocol，即实时传输协议。它由IETF多媒体传输工组小组在1996年在RFC1889中发布，最新的版本为RFC3550.RTP提供了端到端网络传输功能，适用于单播或多播网络中传输音频、
视频等实时数据。

RTCP，Real-time Transport Protocol，它和RTP配合使用，完成实时数据的传输。
RTP只负责传输实时数据，并不保证按时序传输以及服务质量（QoS）保证。
而RTCP主要完成对数据传输的监控，提供最一个最小的控制和识别。
RTCP在设计上能适应大的广播网络，这依赖于对网关根据RTCP报告估计发送端/接收端规模，
动态调整RTCP报告发送间隔。

## 0x00 实时性
这里需要强调的是`实时性`，RTP从设计上就需要考虑到这个因素。
像TCP这样的协议有重传机制，而重传对于实时性要求高的应用是没有太大用处的。
而UDP也不能直接使用，它没有QoS（Quality of Service）保证，且难以同步媒体流。
所以，TCP和UDP都不宜直接用来负载实时数据。

因此出现了RTP和RTCP这两个协议，他们组合起来能保证数据的实时传输。

## 0x01 协议结构
RTP&RTCP在设计上是独立于下层传输层、网络层协议的，因此传输层使用TCP或UDP，网络层使用
IP或ATM都是可以的。通常使用的UDP协议来承载RTP&RTCP协议，RTP和RTCP使用不同端口，
RTP使用偶数端口，RTCP的端口为RTP端口＋1.以下内容，除非声明，否则RTP&RTCP实现都是基于IP+UDP。

因此，通常的RTP&RTCP协议结构如图：

<pre style="background:#aaa;color:#aa0;">
｜－－－－－－－－－－－－｜
｜        App          ｜
｜－－－－－－－－－－－－｜
｜    RTP & RTCP       ｜
｜－－－－－－－－－－－－｜
｜     UDP / TCP       ｜
｜－－－－－－－－－－－－｜
｜     IP / ATM        ｜
｜－－－－－－－－－－－－｜
｜        MAC          ｜
｜－－－－－－－－－－－－｜
</pre>

这里需要注意的是，可以将RTP&RTCP看作是传输层的一部分，也可以看做是应用层的一部分，
这取决你自己站在那个层次来看待。如，对于RTP&RTCP开发者来说，可能会把它归于应用层；而
应用对开放者会将RTP&RTCP&UDP都看作是传输层。

## 0x02 应用场景
RTP的应用场景主要有简单多播音频会议、音频视频会议等。
如果同时使用音频和视频，音频和视频需要在不同的RTP会话中传输。
因此需要两对不同的UDP端口或两对不同的广播地址。


## 0x03 混合器（Mixer）和翻译器（Translator）
在音频和视频会议中，会涉及到混合器和翻译器。

`混合器`是接收一个或多个RTP包，可能会修改数据格式、混合几个包、转发新的包。
包经过混合器后，RTP的SSRC的SSRC会变成混合器的SSRC，而源SSRC则都出现在CSRC列表中，
CSRC个数通过头中的CC（CSRC Count）指出。而且混合器会适当调整时间，会产生新的时间。

目前我们都是假设，会议中所有用户都是使用相同的数据格式。假设有低速链路接入高速链路会议，
为了不使其他用户都使用窄带、质量差的语音编码，通常会在低速链路用户附近引入一个RTP层级的混合器。
对于到达该低速链路用户的包，混合器会重新同步音频数据，将重组后的数据包混合为一个单一的流，
转化为窄带编码，在低速链路上传输。混合器还可能用于视频会议中，将多个用户的视频组合，组成单一的
视频，模拟出真实会议所有人出现都场景。同样，音频会议中常常会将所有用户的声音混合。

`翻译器`转发RTP包而不改变SSRC，只是做格式改变或者单播多播转换。

有些时候由于防火墙等因素存在，无法通过IP广播网络连接高速链路，这时可以在防火墙内外设置两个翻译器，
完成数据格式转换。

## 0x04 RTP报文格式
一个RTP报文头部的格式如下：

<pre>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       sequence number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           synchronization source (SSRC) identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            contributing source (CSRC) identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

头部后面接着的就是RTP净荷（payload）。先说明下头部各个字段的含义。

* V，Version，版本号，目前版本为2，1在之前的草案中使用，0用于vat音频工具。
* P,Padding,填充。有些加密算法需要字节对齐，设置为1，表示净荷后面至少有一个字节的填充。
填充的最后一个字节说明了填充字节个数（包含自己本身），因此这个byte数值至少为1.
* X,eXtension,扩展，如果为1，则至少有一个头部扩展。
* CC,CSRC Count，贡献源个数（0～15）。这个在有Mixer时用到，用于标明头部有多少个CSRC。
* M,Marker,用于标识一些事件，如一帧的开始和结束。如RFC2833中，开始报文Marker设置为1.
* PT,Payload Type,净荷类型，取值范围0～127。标明该报文净荷类型，可以是静态的映射，一个数字对应一种类型。
也可以是动态的，动态情况使用非RTP方法，即带外方式（如信令）来规定。RFC3511中定义了一系列映射关系。
* sequence number，没有RTP报文都有序号，每次发送序号递增。第一个RTP报文的序号是随机产生的，
这样可以增加破解难度。
* timestamp,时间戳，它是第一个数据的采样时间。
* SSRC，synchronization source, 同步源标识。每一个端点都有一个SSRC来标识它，SSRC并不是不变的，
如果用户断开挂机后重新连接，SSRC会改变，或者由于其他原因如冲突也会导致SSRC变化。
SSRC变化后，相关的RTCP统计数据也需要清除，从0开始。
* CSRC，Contributing Srouce，这个用于混合器中，CC字段表明了CSRC的个数。一般情况，可以没有CSRC。
